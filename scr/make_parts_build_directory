#! /usr/bin/env python
import os
import shutil
import sys

import ide
from ide import path as _path
from ide import segments as _segments

import abjad

# lilypond.org/doc/v2.19/Documentation/notation/predefined-paper-sizes
paper_size_to_paper_dimensions = {
    "a3": "297 x 420 mm",
    "a4": "210 x 297 mm",
    "arch a": "9 x 12 in",
    "arch b": "12 x 18 in",
    "arch c": "18 x 24 in",
    "arch d": "24 x 36 in",
    "arch e": "36 x 48 in",
    "legal": "8.5 x 14 in",
    "ledger": "17 x 11 in",
    "letter": "8.5 x 11 in",
    "tabloid": "11 x 17 in",
}

known_paper_sizes = list(paper_size_to_paper_dimensions.keys())


# TODO: externalize
def _collect_segment_lys(directory):
    paths = directory.segments.list_paths()
    names = [_.name for _ in paths]
    sources, targets = [], []
    for name in names:
        source = directory.segments / name / "illustration.ly"
        if not source.is_file():
            continue
        target = "segment-" + name.replace("_", "-") + ".ly"
        target = directory._segments / target
        sources.append(source)
        targets.append(target)
    if not directory.builds.is_dir():
        directory.builds.mkdir()
    return zip(sources, targets)


# TODO: externalize
def _copy_boilerplate(directory, source_name, target_name=None, values=None):
    target_name = target_name or source_name
    target = directory / target_name
    if target.exists():
        print(f"Removing {target.trim()} ...")
    print(f"Writing {target.trim()} ...")
    values = values or {}
    boilerplate = _path.Path(ide.Configuration().boilerplate_directory)
    source = boilerplate / source_name
    target_name = target_name or source_name
    target = directory / target_name
    shutil.copyfile(str(source), str(target))
    if not values:
        return
    template = target.read_text()
    template = template.format(**values)
    target.write_text(template)


def _generate_back_cover_tex(path, price=None):
    assert path.build.exists(), repr((path, path.build))
    name = "back-cover.tex"
    assert path.name.endswith(name)
    directory = path.build
    local_template = directory._assets / name
    if local_template.is_file():
        print(f"Removing {path.trim()} ...")
        path.remove()
        print(f"Copying {local_template.trim()} ...")
        print(f"Writing {path.trim()} ...")
        shutil.copyfile(str(local_template), str(path))
        if price is not None:
            text = path.read_text()
            if "_PRICE" in text:
                text = text.replace("_PRICE", price)
            path.write_text(text)
        return
    values = {}
    string = "catalog_number"
    catalog_number = directory.contents.get_metadatum(string, r"\null")
    if path.build.is_part():
        metadata = path.build.parent.get_metadata()
    else:
        metadata = path.build.get_metadata()
    if catalog_number:
        suffix = metadata.get("catalog_number_suffix")
        if suffix:
            catalog_number = f"{catalog_number} / {suffix}"
    values["catalog_number"] = catalog_number
    composer_website = abjad.Configuration().composer_website or ""
    values["composer_website"] = composer_website
    if price is None:
        price = metadata.get("price", r"\null")
        if "$" in price and r"\$" not in price:
            price = price.replace("$", r"\$")
    values["price"] = price
    paper_size = metadata.get("paper_size", "letter")
    if paper_size not in known_paper_sizes:
        print(f"Unknown paper size {paper_size} ...")
        sys.exit(-1)
    orientation = metadata.get("orientation")
    dimensions = _to_paper_dimensions(paper_size, orientation)
    width, height, unit = dimensions
    paper_size = f"{{{width}{unit}, {height}{unit}}}"
    values["paper_size"] = paper_size
    target_name = path.name
    _copy_boilerplate(
        directory, "back-cover.tex", target_name=target_name, values=values
    )


def _generate_front_cover_tex(path, forces_tagline=None):
    assert path.build.exists(), repr(path)
    directory = path.build
    name = "front-cover.tex"
    local_template = directory._assets / name
    if local_template.is_file():
        print(f"Removing {path.trim()} ...")
        path.remove()
        print(f"Copying {local_template.trim()} ...")
        print(f"Writing {path.trim()} ...")
        shutil.copyfile(str(local_template), str(path))
        if forces_tagline is not None:
            text = path.read_text()
            if "_FORCES_TAGLINE" in text:
                text = text.replace("_FORCES_TAGLINE", forces_tagline)
            path.write_text(text)
        return
    values = {}
    score_title = directory.contents.get_title(year=False)
    score_title = score_title.upper()
    values["score_title"] = score_title
    if not forces_tagline:
        string = "forces_tagline"
        forces_tagline = directory.contents.get_metadatum(string, "")
    if forces_tagline:
        forces_tagline = forces_tagline.replace("\\", "")
    values["forces_tagline"] = forces_tagline
    year = directory.contents.get_metadatum("year", "")
    values["year"] = str(year)
    composer = abjad.Configuration().composer_uppercase_name
    values["composer"] = str(composer)
    paper_size = directory.get_metadatum("paper_size", "letter")
    orientation = directory.get_metadatum("orientation")
    paper_size = _to_paper_dimensions(paper_size, orientation)
    width, height, unit = paper_size
    paper_size = f"{{{width}{unit}, {height}{unit}}}"
    values["paper_size"] = paper_size
    target_name = None
    target_name = path
    _copy_boilerplate(directory, name, target_name=target_name, values=values)

def _generate_part_music_ly(
    path,
    dashed_part_name=None,
    forces_tagline=None,
    keep_with_tag=None,
    part=None,
    part_subtitle=None,
    silent=None,
):
    assert path.build.exists(), repr(path)
    print(f"Generating {path.trim()} ...")
    if path.exists():
        print(f" Removing {path.trim()} ...")
        path.remove()
    segments = path.segments.list_paths()
    if not segments:
        print(" No segments found ...")
    names = [_.stem.replace("_", "-") for _ in segments]
    boilerplate = "part-music.ly"
    _copy_boilerplate(path.build, boilerplate, target_name=path.name)
    lines, ily_lines = [], []
    for i, name in enumerate(names):
        name = "segment-" + name + ".ly"
        ly = path.build._segments / name
        if ly.is_file():
            line = rf'\include "../_segments/{name}"'
        else:
            line = rf'%\include "../_segments/{name}"'
        ily_lines.append(line.replace(".ly", ".ily"))
        if 0 < i:
            line = 8 * " " + line
        lines.append(line)
    if lines:
        segment_ily_include_statements = "\n".join(ily_lines)
    else:
        segment_ily_include_statements = ""
    language_token = abjad.LilyPondLanguageToken()
    lilypond_language_directive = abjad.lilypond(language_token)
    version_token = abjad.LilyPondVersionToken()
    lilypond_version_directive = abjad.lilypond(version_token)
    annotated_title = path.contents.get_title(year=True)
    if annotated_title:
        score_title = annotated_title
    else:
        score_title = path.contents.get_title(year=False)
    score_title_without_year = path.contents.get_title(year=False)
    if forces_tagline is None:
        string = "forces_tagline"
        forces_tagline = path.contents.get_metadatum(string, "")
    if forces_tagline:
        forces_tagline = forces_tagline.replace("\\", "")
    assert path.is_file(), repr(path)
    template = path.read_text()
    if path.parent.is_part():
        identifiers = _segments.global_skip_identifiers(path)
        identifiers = ["\\" + _ for _ in identifiers]
        newline = "\n" + 24 * " "
        global_skip_identifiers = newline.join(identifiers)
        dictionary = _make_container_to_part_assignment(path)
        identifiers = _segments.part_to_identifiers(path, part, dictionary)
        if isinstance(identifiers.capitalize(), str):
            print(" " + identifiers)
            message = f" Removing {path.trim()} ..."
            print(message)
            path.remove()
            return
        identifiers = ["\\" + _ for _ in identifiers]
        newline = "\n" + 24 * " "
        segment_ly_include_statements = newline.join(identifiers)
        template = template.format(
            dashed_part_name=dashed_part_name,
            forces_tagline=forces_tagline,
            global_skip_identifiers=global_skip_identifiers,
            lilypond_language_directive=lilypond_language_directive,
            lilypond_version_directive=lilypond_version_directive,
            part_identifier=repr(part.identifier),
            part_subtitle=part_subtitle,
            score_title=score_title,
            score_title_without_year=score_title_without_year,
            segment_ily_include_statements=segment_ily_include_statements,
            segment_ly_include_statements=segment_ly_include_statements,
        )
    path.write_text(template)

def _generate_part_tex(path, dashed_part_name):
    assert path.build.exists(), repr(path)
    assert path.build.is_parts() or path.build.is_part(), repr(path)
    directory = path.build
    name = "part.tex"
    local_template = directory._assets / name
    if local_template.is_file():
        print(f"Removing {path.trim()} ...")
        path.remove()
        print(f"Copying {local_template.trim()} ...")
        print(f"Writing {path.trim()} ...")
        shutil.copyfile(str(local_template), str(path))
        return
    values = {}
    values["dashed_part_name"] = dashed_part_name
    if path.build.is_part():
        metadata = path.build.parent.get_metadata()
    else:
        metadata = path.build.get_metadata()
    paper_size = metadata.get("paper_size", "letter")
    orientation = metadata.get("orientation")
    paper_size = _to_paper_dimensions(paper_size, orientation)
    width, height, unit = paper_size
    paper_size = f"{{{width}{unit}, {height}{unit}}}"
    values["paper_size"] = paper_size
    target_name = path.name
    _copy_boilerplate(directory, name, target_name=target_name, values=values)

def _generate_preface_tex(path):
    assert path.build.exists(), repr(path)
    directory = path.build
    name = "preface.tex"
    local_template = directory._assets / name
    if local_template.is_file():
        print(f"Removing {path.trim()} ...")
        path.remove()
        print(f"Copying {local_template.trim()} ...")
        print(f"Writing {path.trim()} ...")
        shutil.copyfile(str(local_template), str(path))
        return
    values = {}
    if path.build.is_part():
        metadata = path.build.parent.get_metadata()
    else:
        metadata = path.build.get_metadata()
    paper_size = metadata.get("paper_size", "letter")
    orientation = metadata.get("orientation")
    paper_size = _to_paper_dimensions(paper_size, orientation)
    width, height, unit = paper_size
    paper_size = f"{{{width}{unit}, {height}{unit}}}"
    values["paper_size"] = paper_size
    if path.build.is_part():
        name = "part-preface.tex"
        target_name = f"{path.build.name}-preface.tex"
    else:
        name = "score-preface.tex"
        target_name = path.name
    _copy_boilerplate(directory, name, target_name=target_name, values=values)

# TODO: externalize    
def _make_container_to_part_assignment(directory):
    pairs = _collect_segment_lys(directory.build)
    if not pairs:
        print("... no segment lys found.")
        sys.exit(-1)
    container_to_part_assignment = abjad.OrderedDict()
    for source, target in pairs:
        segment = source.parent
        value = segment.get_metadatum(
            "container_to_part_assignment", file_name="__persist__.py"
        )
        if value:
            container_to_part_assignment[segment.name] = value
    return container_to_part_assignment


# TODO: externalize?
def _part_subtitle(part_name, parentheses=False):
    words = abjad.String(part_name).delimit_words()
    number = None
    try:
        number = int(words[-1])
    except ValueError:
        pass
    if number is not None:
        if parentheses:
            words[-1] = f"({number})"
        else:
            words[-1] = str(number)
    words = [_.lower() for _ in words]
    part_subtitle = " ".join(words)
    return part_subtitle


def _to_paper_dimensions(paper_size, orientation="portrait"):
    orientations = ("landscape", "portrait", None)
    assert orientation in orientations, repr(orientation)
    paper_dimensions = paper_size_to_paper_dimensions[paper_size]
    paper_dimensions = paper_dimensions.replace(" x ", " ")
    width, height, unit = paper_dimensions.split()
    if orientation == "landscape":
        height_ = width
        width_ = height
        height = height_
        width = width_
    return width, height, unit


directory = os.getcwd()
directory = ide.Path(directory)
if directory.name != "builds":
    print("Call script in builds directory ...")
    sys.exit(-1)

build_name = None
for string in sys.argv[1:]:
    if string.startswith("--name="):
        build_name = string[7:]

if build_name is None:
    print("Provide --name=build_name ...")
    sys.exit(-1)

print("Getting part names from score template ...")
part_manifest = _segments.get_part_manifest(directory)
part_names = [_.name for _ in part_manifest]
for part_name in part_names:
    print(f"Found {part_name} ...")

name = build_name
parts_directory = directory / name
if parts_directory.exists():
    print(f"Existing {parts_directory.trim()} ...")
    sys.exit(-1)
paper_size = "letter"
orientation = "portrait"
names = (
    "front-cover.tex",
    "preface.tex",
    "music.ly",
    "back-cover.tex",
    "part.tex",
)

print("Making ...")
print(f"    {parts_directory.trim()}")
path = parts_directory / "stylesheet.ily"
print(f"    {path.trim()}")
for part_name in part_names:
    dashed_part_name = abjad.String(part_name).to_dash_case()
    for name in names:
        name = f"{dashed_part_name}-{name}"
        path = parts_directory / dashed_part_name / name
        print(f"    {path.trim()}")
assert not parts_directory.exists()
parts_directory.mkdir()
parts_directory.add_metadatum("parts_directory", True)
if bool(paper_size):
    parts_directory.add_metadatum("paper_size", paper_size)
if not orientation == "portrait":
    parts_directory.add_metadatum("orientation", orientation)
os.system(f"collect_segment_lys --directory={parts_directory}")
stub = parts_directory.builds._assets / "preface-body.tex"
if not stub.is_file():
    stub.write_text("")
stub = parts_directory.builds._assets / "preface-colophon.tex"
if not stub.is_file():
    stub.write_text("")
print("Generating stylesheet ...")
values = {}
paper_size = parts_directory.build.get_metadatum("paper_size", "letter")
values["paper_size"] = paper_size
orientation = parts_directory.build.get_metadatum("orientation", "")
values["orientation"] = orientation
_copy_boilerplate(parts_directory.build, "stylesheet.ily", values=values)
total_parts = len(part_manifest)
for i, part in enumerate(part_manifest):
    dashed_part_name = abjad.String(part.name).to_dash_case()
    part_directory = parts_directory / dashed_part_name
    part_directory.mkdir()
    snake_part_name = abjad.String(part.name).to_snake_case()
    part_subtitle = _part_subtitle(part.name, parentheses=True)
    forces_tagline = _part_subtitle(part.name) + " part"
    _generate_back_cover_tex(
        part_directory / f"{dashed_part_name}-back-cover.tex",
        price=f"{part.identifier} ({part.number}/{total_parts})",
    ),
    _generate_front_cover_tex(
        part_directory / f"{dashed_part_name}-front-cover.tex",
        forces_tagline=forces_tagline,
    )
    _generate_part_music_ly(
        part_directory / f"{dashed_part_name}-music.ly",
        dashed_part_name=dashed_part_name,
        forces_tagline=forces_tagline,
        keep_with_tag=part.name,
        part=part,
        part_subtitle=part_subtitle,
        silent=True,
    )
    _generate_part_tex(
        part_directory / f"{dashed_part_name}-part.tex",
        dashed_part_name,
    )
    _generate_preface_tex(
        part_directory / f"{dashed_part_name}-preface.tex"
    )
    _copy_boilerplate(
        part_directory,
        "part_layout.py",
        target_name=f"{snake_part_name}_layout.py",
        values={"part_identifier": part.identifier},
    )
