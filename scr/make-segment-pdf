#! /usr/bin/env bash

source lib-path-manipulation
source make-layout-ly

boilerplate=/Users/trevorbaca/ide/boilerplate


helper() {

    segment_directory=$1

    if [ -a layout.py ]; then
        layout_py_path=$(realpath layout.py)
        directory=$(dirname "$layout_py_path")
        filename=$(basename -- "$layout_py_path")
        filename="${filename%.*}"
        layout_ly_path="$directory"/"$filename".ly
        SECONDS=0
        make_layout_ly "$layout_py_path"
        if [ -f "$layout_ly_path" ]; then
            echo Found $(trim_score_path "$layout_ly_path") ...
        else
            echo Can not produce $(trim_score_path "$layout_ly_path") ...
        fi
        if [ "$SECONDS" -eq 1 ]; then
            echo "Total time ${SECONDS} second ..."
        else
            echo "Total time ${SECONDS} seconds ..."
        fi
    fi

    segment_name=$(basename "$segment_directory")
    definition="$segment_directory"/definition.py
    if [ ! -f "$definition" ]; then
        echo "Can not find $definition ..."
        return
    fi
    echo "Making segment $(basename "$segment_directory") PDF ..."
    ly="$segment_directory"/illustration.ly
    if [ -a "$ly" ]; then
        echo "Removing $(trim_score_path "$ly") ..."
        rm "$ly"
    fi

    pdf="$segment_directory"/illustration.pdf
    backup_pdf="$segment_directory"/illustration._backup.pdf
    if [ -a "$pdf" ]; then
        cp "$pdf" "$backup_pdf"
        echo "Removing $(trim_score_path "$pdf") ..."
        rm "$pdf"
    fi

    maker_name=__make_segment_pdf__.py
    maker_source="$boilerplate"/"$maker_name"
    maker_target="$segment_directory"/"$maker_name"
    if [ -a "$maker_target" ]; then
        rm "$maker_target"
    fi
    echo Writing $(trim_score_path "$maker_target") ...
    cp "$maker_source" "$maker_target"

    if [ "$segment_name" == "01" ]; then
        statement="previous_metadata = None"
        persist_statement="previous_persist = None"
    else
        previous_segment=$(get_previous_sibling_directory "$segment_directory")
        metadata="$previous_segment"/__metadata__.py
        statement="file = ide.Path('$metadata')"
        statement="$statement
        lines = file.read_text()"
        statement="$statement
        exec(lines)"
        statement="$statement
        previous_metadata = metadata"
        persist="$previous_segment"/__persist__.py
        persist_statement="file = ide.Path('$persist')"
        persist_statement="$persist_statement
        lines = file.read_text()"
        persist_statement="$persist_statement
        exec(lines)"
        persist_statement="$persist_statement
        previous_persist = persist"
    fi

    boil "$maker_target" previous_segment_metadata_import_statement "$statement" \
        previous_segment_persist_import_statement "$persist_statement"

    echo Interpreting $(trim_score_path "$maker_target") ...
    python "$maker_target"
    echo Removing $(trim_score_path "$maker_target") ...
    rm "$maker_target"
    ly="$segment_directory"/illustration.ly
    if [ -a "$ly" ]; then
        echo Found $(trim_score_path "$ly") ...
    fi
    if [ -a "$pdf" ]; then
        echo Found $(trim_score_path "$pdf") ...
        rm "$backup_pdf"
        if [ $2 == "do_open" ]; then
            echo Opening $(trim_score_path "$pdf") ...
            open "$pdf"
        fi
    elif [ -a "$backup_pdf" ]; then
        cp "$backup_pdf" "$pdf"
    fi

}


make_segment_pdf() {
    current_directory=$(pwd)
    current_basename=$(basename "$current_directory")
    parent_basename=$(basename $(dirname "$current_directory"))
    if [ $current_basename != segments ]; then
        if [ $parent_basename != segments ]; then
            echo Call in segment directory or segments directory ...
            return
        fi
        helper $(pwd) do_open
        echo
    else
        paths=$(ls -d [0-9]*)
        for path in $paths; do
            segment_directory=$(realpath $path)
            cd $segment_directory
            helper $segment_directory do_not_open
            cd $current_directory
            echo
        done
    fi
}
