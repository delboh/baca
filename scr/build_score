#! /usr/bin/env python
import io
import os
import shutil
import subprocess
import sys

import ide
from ide import path as _path
from ide import segments as _segments

import abjad

# lilypond.org/doc/v2.19/Documentation/notation/predefined-paper-sizes
paper_size_to_paper_dimensions = {
    "a3": "297 x 420 mm",
    "a4": "210 x 297 mm",
    "arch a": "9 x 12 in",
    "arch b": "12 x 18 in",
    "arch c": "18 x 24 in",
    "arch d": "24 x 36 in",
    "arch e": "36 x 48 in",
    "legal": "8.5 x 14 in",
    "ledger": "17 x 11 in",
    "letter": "8.5 x 11 in",
    "tabloid": "11 x 17 in",
}


# TODO: externalize
def _copy_boilerplate(directory, source_name, target_name=None, values=None):
    target_name = target_name or source_name
    target = directory / target_name
    if target.exists():
        print(f"Removing {target.trim()} ...")
    print(f"Writing {target.trim()} ...")
    values = values or {}
    boilerplate = _path.Path(ide.Configuration().boilerplate_directory)
    source = boilerplate / source_name
    target_name = target_name or source_name
    target = directory / target_name
    shutil.copyfile(str(source), str(target))
    if not values:
        return
    template = target.read_text()
    template = template.format(**values)
    target.write_text(template)


# TODO: externalize
def _display_lilypond_log_errors(log=None):
    if log is None:
        log = abjad_configuration.lilypond_log_file_path
    log = _path.Path(log)
    with log.open() as file_pointer:
        lines = file_pointer.readlines()
    for line in lines:
        if (
            "fatal" in line
            or ("error" in line and "programming error" not in line)
            or "failed" in line
        ):
            print("ERROR IN LILYPOND LOG FILE ...")
            break


def _generate_document(path):
    directory = path.parent
    values = {}
    paper_size = directory.get_metadatum("paper_size", "letter")
    orientation = directory.get_metadatum("orientation")
    paper_size = _to_paper_dimensions(paper_size, orientation)
    width, height, unit = paper_size
    paper_size = f"{{{width}{unit}, {height}{unit}}}"
    values["paper_size"] = paper_size
    if path.name.endswith("score.tex"):
        name = "score.tex"
    elif path.name.endswith("part.tex"):
        name = "part.tex"
        dashed_part_name = path.name.strip("-part.tex")
        values["dashed_part_name"] = dashed_part_name
    else:
        raise ValueError(path.name)
    _copy_boilerplate(directory, name, target_name=path.name, values=values)


# TODO: externalize
def _interpret_tex_file(tex):
    if not tex.is_file():
        print(f"Can not find {tex.trim()} ...")
        return
    pdf = tex.with_suffix(".pdf")
    if pdf.exists():
        print(f"Removing {pdf.trim()} ...")
        pdf.remove()
    print(f"Interpreting {tex.trim()} ...")
    if not tex.is_file():
        return
    executables = abjad.io.find_executable("xelatex")
    executables = [_path.Path(_) for _ in executables]
    if not executables:
        executable_name = "pdflatex"
    else:
        executable_name = "xelatex"
    log = ide.Configuration().latex_log_file_path
    command = f"date > {log};"
    command += f" {executable_name} -halt-on-error"
    command += " -interaction=nonstopmode"
    command += f" --jobname={tex.stem}"
    command += f" -output-directory={tex.parent} {tex}"
    command += f" >> {log} 2>&1"
    command_called_twice = f"{command}; {command}"
    with abjad.TemporaryDirectoryChange(directory=tex.parent):
        abjad.io.spawn_subprocess(command_called_twice)
        for path in sorted(tex.parent.glob("*.aux")):
            path.remove()
        for path in sorted(tex.parent.glob("*.log")):
            path.remove()
    if pdf.is_file():
        print(f"Found {pdf.trim()} ...")
    else:
        print("ERROR IN LATEX LOG FILE ...")
        log_file = ide.Configuration().latex_log_file_path
        with log_file.open() as file_pointer:
            lines = [_.strip("\n") for _ in file_pointer.readlines()]
        for line in lines:
            print(line)


def _to_paper_dimensions(paper_size, orientation="portrait"):
    orientations = ("landscape", "portrait", None)
    assert orientation in orientations, repr(orientation)
    paper_dimensions = paper_size_to_paper_dimensions[paper_size]
    paper_dimensions = paper_dimensions.replace(" x ", " ")
    width, height, unit = paper_dimensions.split()
    if orientation == "landscape":
        height_ = width
        width_ = height
        height = height_
        width = width_
    return width, height, unit


for string in sys.argv[1:]:
    if string.startswith("--directory="):
        directory = string[12:]
        break
else:
    directory = os.getcwd()
directory = ide.Path(directory)

if directory.parent.name != "builds":
    print("Must run script in score build directory ...")
    sys.exit(-1)

print("Building score ...")
os.system("interpret_build_music --do-not-open")
print()
tex = directory.build / "front-cover.tex"
pdf = directory.build / "front-cover.pdf"
if tex.is_file():
    _interpret_tex_file(directory.build / "front-cover.tex")
elif pdf.is_file():
    print(f"Using existing {pdf.trim()} ...")
else:
    print("Missing front cover ...")
    sys.exit(-1)
print()
tex = directory.build / "preface.tex"
pdf = directory.build / "preface.pdf"
if tex.is_file():
    _interpret_tex_file(directory.build / "preface.tex")
elif pdf:
    print(f"Using existing {pdf.trim()} ...")
else:
    print("Missing preface ...")
    sys.exit(-1)
print()
tex = directory.build / "back-cover.tex"
pdf = directory.build / "back-cover.pdf"
if tex.is_file():
    _interpret_tex_file(directory.build / "back-cover.tex")
elif pdf.is_file():
    print(f"Using existing {pdf.trim()} ...")
else:
    print("Missing back cover ...")
    sys.exit(-1)
print()
print("Generating score ...")
path = directory.build / "score.tex"
_generate_document(path)
print()
_interpret_tex_file(path)
score_pdf = directory.build / "score.pdf"
print(f"Opening {score_pdf.trim()} ...")
os.system(f"open {score_pdf}")
